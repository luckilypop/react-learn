# 函数

# 一、函数的概述

1.1 什么是函数

1. 为了**实现特定功能**的n条语句的封装体；
2. 只有函数可以执行，**重复**调用
3. 一般是**由事件驱动**的；

为什么用函数

1. 提高代码复用
2. 便于阅读交流

函数的定义

如何调用函数

1. test()：直接调用
2. obj.test()：通过对象调用
3. new test()：new调用
4. test.call/apply(obj)：可以让一个函数成为指定任意对象的方法进行调用，临时让test成为obj的方法进行调用

# 二、函数的分类

1. 从定义角度：内置函数、用户自定义函数
2. 从参数角度：有参函数、无参函数
3. 从返回值角度：有返回值函数、无返回值函数

# 三、return

1. 返回值：所谓返回值就是指函数被调用后，向调用者返回的一个数据，函数内部利用return关键字将返回值返回
2. return关键字的使用格式：return 返回值;
3. 注意事项：
   1. 返回值可以是变量、字面量、表达式
   2. 函数内部可以有多个return，但是只能执行一个。因为return关键字除了返回数据，还具有结束函数执行的功能
   3. 如果函数中没有设置return，那么在调用函数时，其实后台会向调用者返回一个值---undefined
   4. 在定义函数时，return和它后面的返回值间不要换行，因为换行后，后台会认为return后面没有返回值
   5. 如果要将return用作结束函数的功能，那么可以采用return;的格式

# 四、函数的创建

## 4.1 函数声明方式

```
function 函数名称() {
	函数体;
}
```

## 4.2 函数表达式方式

1. 函数表达式方式创建的函数是没有名称的函数

2. 变量中存储的是对函数的引用

3. 函数声明方式和函数表达式方式的区别，函数声明方式定义的函数可以在定义之前调用该函数，但是函数表达式方式定义的函数，不可以在定义之前调用。因为函数声明方式定义的函数有函数声明提升操作，而函数表达式方式定义的操作没有函数声明提升操作，只有变量声明提升操作

```
var 变量名称 = function() {
	函数体;
};
```

## 4.3 利用Function构造方法创建函数

1. 构造方法Function中的参数可以有多个，那么前面的参数表示函数的形参，最后一个参数表示函数体

2. 调用方式为：变量名称(实参1，实参2，实参3...);

3. 注意：这种方式定义的函数也不可以在定义之前调用，因为它也只有变量声明提升操作

   ```
   var 变量名称 = new Function('参数1'， '参数2'， '参数3'...);
   ```

## 函数变量提升

# 五、变量的分类

## 5.1 全局变量

1. 定义在函数外部的变量被称为全局变量；
1. 全局变量的作用域是整个文档；

## 5.2 局部变量

1. 定义在函数内部的变量被称为局部变量；
1. 局部变量的作用域是定义它的那个函数；

## 5.3 全局变量和局部变量的区别

1. 全局变量可以在整个文档个中使用
2. 局部变量只能在定义它的函数内部使用
3. .函数内部的形参也是局部变量，也只能在函数内部使用
4. 如果全局变量和局部变量同名，那么全局变量会被屏蔽掉
5. 如果局部变量和全局变量同名，那么要使用全局变量可以在变量名称前面加**window.或this.**因为全局变量是给window对象绑定的属性

## 5.4 变量加 var 和不加 var 的区别

1. 在函数作用域内 加 var 定义的变量是局部变量，**不加 var 定义的就成了"全局变量"** 
2. 在全局作用域下，**使用 var 定义的变量不可以 delete**,没有 var 定义的变量可以 delete.也就说明隐式全局变量严格来说不是真正的变量，而是全局对象(window)的属性，因为属性可以通过 delete 删除，而变量不可以 
3. 使用 var 定义的变量不赋值时会有一个默认初始值：undefined，而不使用 var 定义的变量在 alert()时浏览器会给出错误信息：a is not defined 
4. 在 ECMASceipt5 的'use strict'模式下，如果变量没有使用 var 定义,报错

1. 

# 八、arguments 对象

1. 该对象是函数内部的一个对象，即该对象只能在函数里面使用，不可以在外部使用。它的作用是用来管理函数被调用时传递过来的实参（数据）。它不是一个数组，它是一个**伪数组**。在管理实参时也是用下标的方式对实参进行了编号，即可以使用arguments[下标]的形式操作实参。
2. 注意：Array.isArray(数据)：判断一个元素是否为数组
3. 形参和arguments的关系是：形参和arguments都可以管理实参，而且它们**管理的是同一份数据**。
4. 在操作实参时可以用形参，也可以用arguments，为了方便通常用形参。那么在定义函数时到底需不需要定义形参，如果实参的个数是确定的，那么我们就定义形参，如果**实参的个数是不确定**的时候，就不定义形参。
5. arguments对象包含两个属性：length、callee
   1. length属性：获取实参个数
   2. callee属性：该属性的作用是用来获取arguments对象所在的函数，即callee属性指向了arguments对象所在的函数。常与递归函数结合使用或与匿名自执行函数结合使用

## 8.1 [ES6]:smile:rest参数

<div style=" font-size: 20px;color: #7CFC00 ;background-color: #F08080;font-weight: bold;border-radius: 8px;border-width: 5px;text-align: center">ES6新增</div>

1. ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments
2. 区别：reset返回的数组，可以使用数组的一些方法；arguments返回是一个对象；
3. 注意：rest 参数非常适合不定个数参数函数的场景；
4. 注意：rest 参数(...args)必须要放到参数最后

```javascript
<script>
// ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments
// ES5 获取实参的方式arguments
function date(){
    console.log(arguments); // 返回一个对象，伪数组
}
date('白芷','阿娇','思慧');

// rest 参数：...args
function date(...args){
    console.log(args);// 可以使用数组的一些方法，filter some every map 
}
date('阿娇','柏芝','思慧');

// rest 参数必须要放到参数最后
function fn(a,b,...args){
    console.log(a);
    console.log(b);
    console.log(args); // 返回数组[3,4,5,6]
}
fn(1,2,3,4,5,6);
</script>
```

# 九、特殊函数

## 9.1 重载函数

1. 两个函数的名称相同，但是它们的形参的个数不同，或形参的类型不同，那么我们把这两个函数互称为重载函数
2. 注意：JavaScript中没有重载函数，在JavaScript中如果函数名称相同那么后面的函数会覆盖前面的函数
3. 在JavaScript中模拟重载函数，可以使用arguments对象

## 9.2？高阶函数

## 9.3 递归函数

1. 在一个函数内部有调用了自己的函数被称为递归函数
2. 在使用递归函数时一定要确定递归函数的“出口”，即在某个时刻能够让函数不再调用自己
3. 推荐在递归函数内部使用arguments.callee属性来引用当前函数

## 9.4 匿名函数

1. 没有函数名称的函数，匿名函数可以和事件向结合

## 9.5 匿名自执行函数IIFE

1. Immediately-Invoked Function Expression

1. 没有名称且不需要手动调用的函数
2. 匿名自执行函数通常用来创建块级作用域
3. (function () { })()
4. 作用：隐藏实现；不污染外部(全局)命名空间；用它来编码js模块

## 9.6 回调函数

1. 回调函数：你定义的+你没调用+函数执行了
2. 一个函数被当做另一个函数的参数，那么这个被作为参数的函数就是回调函数，回调函数常用匿名函数。
3. 回调函数通常是在满足某个条件时才会被触发
4. dom事件回调函数：
5. 定时器回调函数：
6. ajax请求回调函数
7. 生命周期回调函数

## 9.7 eval函数

1. 计算字符串的值 

## 9.8:smiley:[ES6]箭头函数

<div style=" font-size: 20px;color: #7CFC00 ;background-color: #F08080;font-weight: bold;border-radius: 8px;border-width: 5px;text-align: center">ES6</div>

1. ES6 允许使用「箭头」（=>）定义函数。

### 9.8.1 格式

```
let fn = (参数，参数...) => {
	// 执行语句
}
```

### 9.8.2 注意事项

1. this是静态的，指向**函数在声明时**所在作用域下 this 的值；即使使用call重新定义this，仍然不变；*[call:“BOM”章节]*--code
1. 不能作为构造函数实例化；[*构造函数*]
1. 不能使用arguments变量；
1. 省略小括号，当形参只有一个时候；
1. 省略花括号，执行语句只有一条；
1. **注意：**箭头函数不会更改this 指向，用来指定回调函数会非常合适

### 9.8.3 适合情况

1. 箭头函数适合与 this 无关的回调. 定时器, 数组的方法回调
2. 箭头函数不适合与 this 有关的回调.  事件回调, 对象的方

## 9.9 构造函数

1. 格式：new function() { … }；
2. 对于构造器有个共同的约定，就是其命名首字母要大写；
3. 从技术上讲，任何函数（除了箭头函数，它没有自己的 `this`）都可以用作构造器。即可以通过 `new` 来运行，它会执行上面的算法

### 9.9.1 构造器模式测试：new.target

1. 使用 new.target 属性来检查它是否被使用 new 进行调用了；

2. 对于常规调用，它为 undefined，对于使用 new 的调用，则等于该函数；

   ```
   function User() {
     alert(new.target);
   }
   
   // 不带 "new"：
   User(); // undefined
   
   // 带 "new"：
   new User(); // function User { ... }
   new User；//如果没有参数，我们可以省略 new 后的括号
   ```

## 9.9.2 构造器的 return

1. 构造器没有 return 语句。它们的任务是将所有必要的东西写入 this，并自动转换为结果

### 9.9.3 构造器中的方法

1. this.方法名

