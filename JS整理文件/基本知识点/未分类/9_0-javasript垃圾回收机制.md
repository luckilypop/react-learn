# 垃圾回收机制

1.垃圾回收是自动完成的，我们不能强制执行或是阻止执行。

# 一、可达性

1. “可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的

# 二、相互关联的对象

# 三、无法到达的岛屿

# 四、mark-and-sweep算法

1. 垃圾收集器找到所有的根，并“标记”（记住）它们。
2. 然后它遍历并“标记”来自它们的所有引用。
3. 然后它遍历标记的对象并标记 **它们的** 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
4. ……如此操作，直到所有可达的（从根部）引用都被访问到。
5. 没有被标记的对象都会被删除。

# 五、优化

1. **分代收集（Generational collection）**—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。
2. **增量收集（Incremental collection）**——  如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。
3. **闲时收集（Idle-time collection）**—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。